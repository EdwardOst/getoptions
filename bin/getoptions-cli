#!/bin/sh

set -euf

SHELLCHECK="shell=sh disable=SC2004,SC2034,SC2145,SC2194"

[ "${ZSH_VERSION:-}" ] && setopt shwordsplit

# https://github.com/ko1nksm/readlinkf
readlinkf() {
	[ "${1:-}" ] || return 1
	max_symlinks=40
	CDPATH='' # to avoid changing to an unexpected directory

	target=$1
	[ -e "${target%/}" ] || target=${1%"${1##*[!/]}"} # trim trailing slashes
	[ -d "${target:-/}" ] && target="$target/"

	cd -P . 2>/dev/null || return 1
	while [ "$max_symlinks" -ge 0 ] && max_symlinks=$((max_symlinks - 1)); do
		if [ ! "$target" = "${target%/*}" ]; then
			case $target in
				/*) cd -P "${target%/*}/" 2>/dev/null || break ;;
				*) cd -P "./${target%/*}" 2>/dev/null || break ;;
			esac
			target=${target##*/}
		fi

		if [ ! -L "$target" ]; then
			target="${PWD%/}${target:+/}${target}"
			printf '%s\n' "${target:-/}"
			return 0
		fi

		# `ls -dl` format: "%s %u %s %s %u %s %s -> %s\n",
		#   <file mode>, <number of links>, <owner name>, <group name>,
		#   <size>, <date and time>, <pathname of link>, <contents of link>
		# https://pubs.opengroup.org/onlinepubs/9699919799/utilities/ls.html
		link=$(ls -dl -- "$target" 2>/dev/null) || break
		target=${link#*" $target -> "}
	done
	return 1
}

self=$(readlinkf "$0")
bin=${self%/*}

# shellcheck source=bin/getoptions
. "$bin/getoptions"

parser_definition() {
	setup REST help:usage abbr:true width:24 error -- \
		"Usage: ${2##*/} [options]... <command> [arguments]... " '' \
		'Options:'

	disp :usage -h --help -- "Display this help and exit"
	disp VERSION -v --version -- "Display the version and exit"

	msg -- '' 'Commands:'

	cmd parser -- 'Generate parser'
	cmd example -- 'Generate example'

	msg -- ''
	msg -- "URL: $URL"
	msg -- "License: $LICENSE"
}

parser_definition_parser() {
	setup REST help:usage abbr:true mode:+ width:24 error -- \
		"Usage: ${2##*/} parser [options]... <file> <parser> [arguments]..." '' \
		'Options:'

	param DEFINITION -d --definition var:NAME -- \
		"Specify the parser definition name" \
		"  [default: filename without extensions]"

	option INDENT -i --indent on:2 validate:number var:N -- \
		"Use N spaces instead of tabs for indentation [default: 2]"

	option SHELLCHECK --shellcheck var:DIRECTIVES on:"$SHELLCHECK" -- \
		"Embed the shellcheck directives" "  [default: '$SHELLCHECK']"

	flag COMMENT --no-comments init:@on -- \
		"Do not embed comments"

	param ARG --optarg -- \
		"Use ARG instead of the variable name OPTARG"

	param IND --optind -- \
		"Use IND instead of the variable name OPTIND"

	disp :usage -h --help -- "Display this help and exit"
}

number() {
	case $OPTARG in (*[!0-9]*)
		return 1
	esac
	return 0
}

abort() {
	echo "$@" >&2
	exit 1
}

error() {
	case $2 in
		number:*) echo "Not a number: $3" ;;
		*) return 0 ;;
	esac
	return 1
}

parser_definition_not_found() {
	abort "The parser definition '$1' not found"
}

is_valid_identifier() {
	case $1 in (*[!a-zA-Z0-9_]*) return 1; esac
	return 0
}

parse_shellcheck_directives() {
	shellcheck_shell='' shellcheck_disable=''
	# shellcheck disable=SC2086
	set -- $1
	while [ $# -gt 0 ]; do
		case $1 in
			shell=*) shellcheck_shell=${1#*\=} ;;
			disable=*) shellcheck_disable=${1#*\=} ;;
		esac
		shift
	done
}

comment() {
	[ "$COMMENT" ] || return 0
	echo "#" "$@"
}

shellcheck() {
	[ "$2" ] || return 0
	printf '# shellcheck %s=%s\n' "$1" "$2"
}

replace_all() {
	if [ $# -lt 4 ]; then
		eval "set -- \"\$1\" \"\${$1}\" \"\$2\" \"\$3\" \"\""
	else
		set -- "$1" "$2" "$3" "$4" ""
	fi
	while :; do
		case $2 in
			*"$3"*) set -- "$1" "${2#*"$3"}" "$3" "$4" "$5${2%%"$3"*}$4" ;;
			*) break ;;
		esac
	done
	eval "$1=\$5\$2"
}

chvarname() {
	while IFS= read -r line; do
		[ "$ARG" ] && replace_all line OPTARG "$ARG"
		[ "$IND" ] && replace_all line OPTIND "$IND"
		printf '%s\n' "$line"
	done
}

do_parser() {
	eval "$("$bin/getoptions" parser_definition_parser parse "$0")"
	parse "$@"
	eval "set -- $REST"
	[ $# -lt 2 ] && usage && exit 1

	if [ ! "$DEFINITION" ]; then
		DEFINITION=${1##*/} && DEFINITION=${DEFINITION%%.*}
	fi
	file=$1 parser=$2
	shift
	set -- "$DEFINITION" "$@"

	if ! is_valid_identifier "$DEFINITION"; then
		abort "The parser definition name '$DEFINITION' is not a valid name"
	fi
	if ! is_valid_identifier "$parser"; then
		abort "The parser name '$parser' is not a valid name"
	fi

	eval "$DEFINITION() { parser_definition_not_found \"\$DEFINITION\"; }"
	# shellcheck disable=SC1090
	. "$file"
	generated=$(getoptions "$@")
	printf '%s\n' "$generated" | {
		parse_shellcheck_directives "$SHELLCHECK"
		shellcheck shell "$shellcheck_shell"
		comment "Generated by getoptions (BEGIN)"
		comment "URL: $URL ($VERSION)"
		while IFS= read -r line; do
			if [ "$line" = "$parser() {" ]; then
				shellcheck disable "$shellcheck_disable"
			fi
			printf '%s\n' "$line"
		done
		comment "Generated by getoptions (END)"
	} | tab2space "$INDENT" | chvarname
}

do_example() {
cat<<'HERE'
parser_definition() {
  setup   REST plus:true help:usage abbr:true \
    -- "Usage: ${2##*/} [options...] [arguments...]" ''
  msg -- 'Options:'
  flag    FLAG    -f +f --{no-}flag
  flag    VERBOSE -v    --verbose   counter:true init:=0
  param   PARAM   -p    --param     pattern:"foo | bar"
  option  OPTION  -o    --option    on:"default" validate:number
  disp    :usage  -h    --help
  disp    VERSION       --version
}
eval "$(getoptions parser_definition parse "$0")"
parse "$@"
eval "set -- $REST"
HERE
}

eval "$("$bin/getoptions" parser_definition parse "$0")"
parse "$@"
eval "set -- $REST"

case ${1:-} in
	parser) shift; do_parser "$@" ;;
	example) shift; do_example "$@" ;;
	*) usage && exit 1 ;;
esac
